\section{The Protocol}
\subsection{Notation}
Before explaining the protocol we introduce the following notation, based
  in the work of Andrychowicz et al. \cite{andrychowicz2014secure}, to describe
  the transactions.

Table~\ref{tx:example} represents a transaction that spends two outputs from
  two different previous transaction and creates three outputs:

  \transaction
    {x}{y1,y2}
    % Inputs
      {y1}{$\alpha$}{$\sigma_1$}
      {y2}{$\beta$}{$\sigma_2$}
      \stopinputs
    % Outputs
      {$\nu_1$}{$\gamma_1$}
      {$\nu_2$}{$\gamma_2$}
      {$\nu_3$}{$\gamma_3$}
      \stopoutputs
    % Caption
      {tx:example}
      {Transaction notation example.}

\begin{itemize}
    \item \transactionize{x}: Transaction's name/id.
    \item \transactionize{y1,y2}: Transactions being spent.
    \item $\alpha,\beta$: Indexes of the output being spent, this is the
                            position the outputs appear in its transaction,
                            starting from 0.
    \item $\sigma_1,\sigma_2$: Input script, values required to satisfy the
                                output script being spent.
    \item $\nu_1,\nu_2,\nu_3$: Value of the output.
    \item $\gamma_1, \gamma_2, \gamma_3$: Outputs' script, need to be satisfied
                                          in order to spend its corresponding
                                          output.
\end{itemize}

For the scripts we use the logical conjunction ($\wedge$) when both propositions
  must be satisfied.
Logical disjunction ($\vee$) when we need to satisfy only one of the
  propositions.
Signatures always sign its own transaction, when a signature from the
  participant $A$ is required, we say: \signature{A}.
Sometime a literal is required, usually a preimage of a known hash ($H(l)$), we
  use just $l$. Some paths of the transaction are unreachable before a defined
  time, we use \timeout{k} to disable the path this expressions is in before the
  time $k$.

For instance, the script at~\ref{eq:notation_sample} requires to be evaluated
  after the time $k$ and a signature of $U$. Or $l$ and a signature of $U$.
\begin{equation} \label{eq:notation_sample}
    \mathcal{S}_U \wedge (l \vee \uptau_k)
\end{equation}
\mathmode

\subsection{First part: Oracle Selection}

The oracles are a key piece in the protocol, as they get to decide who gets
  the prize money.
The first part of the protocol defines a way to select them in a trustless
  way.
The idea is quite simple, players selects from a list of oracles a subset
  to participate on its bet.
With a big enough list, selecting randomly from it reduces the
  chances from any of the participants to influence on the selection.

\subsubsection{Oracle list}

In order to get a trustworthy list, we define a few key properties:
It must be a decentralized list; anybody willing to be an oracle can enroll
  itself; and must be visible for both of the players.

As we saw in sub section~\ref{subsec:Blockchain}, we already have a
  public distributed database to store information.
We use the blockchain to keep the list of oracles, this provides tampering
  protection, a public database and a distributed source for the list.
In order to let anybody enroll to be an oracle, the enrollment is a simple
 transaction generated by the oracle and sent to the blockchain.
We defined our own string as protocol indentification, but different protocols
  can use different strings to define other lists.

\subsubsection{Oracle registration}

\transaction
    {Registration}{oracle previous tx}
    % Inputs
      {Oracle previous tx}{$\alpha$}{$\sigma$}
      \stopinputs
    % Outputs
      {$\nu$}{$\gamma$}
      {$0$}{OP\_RETURN \{ENROLLMENT DATA\}}
      \stopoutputs
    % Caption
      {tx:registration}
      {Oracle Registration.}

In this registration transaction the oracle takes money from a controlled
  unspent output and returns all the money where it wants in the first
  output.
The registration happens with the second output. OP\_RETURNS makes this output
  invalid, so nobody can spend it.
Which don't matter that much, as the value is zero. But the operation allows
  us to insert arbitrary data, and it's here where we enter a defined string
  saying the oracle's address and its will to participate as oracle.

There is no required deposit for registration, however the transaction fee must
  be paid when sending the transaction.
Some may argue than a higher price to register an oracle will decrease the
  chances of an individual controlling the majority of the list.
If that is the case, increasing the cost by adding a required a unspendable
output does not require any change in the transaction~\ref{tx:registration},
  as the unspendable output already exist.
Adding a deposit spendable by an address will require a new output, but the
  idea remain the same.

When this transaction is submitted to the blockchain, players can look into
  this transaction and recognize it as an oracle registration.

\subsubsection{Compiling oracle list}

There are a few parameters players must agree in order to select oracles from
  the blockchain list.
First they decide the period of time\footnote{Measured as a range of blocks in
  the blockchain.} they will consider oracles from.
Some participants might want to avoid recently registered oracles, as they might
  have an higher chance to be controlled by the other player.
Others might argue too old oracles are likely to be inactive, in order to avoid
  oracles registered long time ago.

Second, they decide the list to get the oracles from, and if they want to filter
  out oracles, for example they might decide to exclude oracles that paid less
  than $b$ bitcoins on fees at registration time.
Finally they decide the number of oracles to use, also they can decide to
  select a few more than the required oracles, anticipating one or more of
  the selected oracles will not reply to the invitation.

Once they decide the filter and which blocks to use for retrieve the oracles,
  both players can compile the same list of availables oracles.
Hashing the list and compare the hashes helps the users to be sure they had
  compiled the same list.
This list is the source for selecting the oracles to use, players just need to
  decide which of them to use.

\subsubsection{Oracle selection}

If this list is big and there is a cost to enroll on it, a random selection
  from it decreases the chance for any player to get a possible controlled
  oracle into the final list.
And decreases even more to control the majority of them, required to decide
  the bet.

As trust in the other player is not required for this protocol, both players
need to have the certainty the election from the list is random.
In order to achieve this property we use a protocol originally proposed to flip
  coins over the phone \cite{blum1983coin}.
Today this algorithm is mostly known as ``Coin Tossing'', and lives in a
  subfield of cryptography called Multi Party Computation.
Multi party computation, or secure multi party computation aims to provide
  protocols for computing public functions and gets its results while
  participants keeps their input private.

The idea of the Coin Tossing we use is to get a random bit, as neither of the
  players trust the other to select the bit randomly, both players select a bit
  and the they XOR it with the other one.
This way, does not matter how the other bit was chosen, the result is random.
There is one important restriction when using this protocol, the bit must be
  chosen before knowing the value of  the other, otherwise if one bit is known
  the second one can be selected in order to get the desired outcome.
If we were physically together we would write down the bit in a paper, wait for
  the other player to write his and then reveal both bits and perform the XOR\@.
However we would like to run this algorithm through the phone or in this case
  the computer.
The idea is the same, but instead of writting down into a paper, players
  ``commit'' to the value they just chose randomly by sending to the other
  player a ``commitment''.
This commitment binds the player to the value calculated, without revealing it.
Once both players receive the other's commitment, they send the bit they chose.
They check the received value against the previously received commitment, and if
  they match, the protocol outputs a random bit.
Otherwise, a player tried to cheat and the protocol aborts as there is no way to
  calculate a random bit.

If we have a list both players agree with, and we can also produce random bits,
  selecting a number of oracles from the list is a trivial exercise.
After this step, players had decide the oracles to use.
We represent the total number of oracles participating in the protocol by a $n$,
  and the required number to decide the bet as $m$, where $\frac{n}{2} < m$.

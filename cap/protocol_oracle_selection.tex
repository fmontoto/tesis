\section{Protocol Description}
\subsection{Notation}
Before explaining the protocol we introduce the following notation, based
  on the work of Andrychowicz et al. \cite{andrychowicz2014secure}, to describe
  the transactions.

Table~\ref{tx:example} represents a transaction that spends two outputs from
  two different previous transactions and creates three outputs:

  \transaction
    {x}{y1,y2}
    % Inputs
      {y1}{$\alpha$}{$\sigma_1$}
      {y2}{$\beta$}{$\sigma_2$}
      \stopinputs
    % Outputs
      {$\nu_1$}{$\gamma_1$}
      {$\nu_2$}{$\gamma_2$}
      {$\nu_3$}{$\gamma_3$}
      \stopoutputs
    % Caption
      {tx:example}
      {Transaction notation example.}

\begin{itemize}
    \item \transactionize{x}: Transaction's name/id.
    \item \transactionize{y1,y2}: Transactions being spent.
    \item $\alpha,\beta$: Indexes of the output being spent, this is the
                            position the outputs appear in its transaction,
                            starting from 0.
    \item $\sigma_1,\sigma_2$: Input script, values required to satisfy the
                                output script being spent.
    \item $\nu_1,\nu_2,\nu_3$: Value of the output.
    \item $\gamma_1, \gamma_2, \gamma_3$: Output scripts, need to be satisfied
                                          in order to spend its corresponding
                                          output.
\end{itemize}

For the scripts we use the logical conjunction ($\wedge$) when both propositions
  must be satisfied.
Logical disjunction ($\vee$) when we need to satisfy only one of the
  propositions.
Signatures always sign the transaction they are included on, this makes the
  signature valid only for the transaction it was created.
When a signature from the participant $A$ is provided, we denote: \signature{A}.
Sometimes a literal is required, usually a preimage of a known hash ($H(l)$).
In that case, we just use $l$.
Some branches of the transaction's script are locked before a defined time, we
  use \timeout{k} to disable the branch this expressions is in before the
  time $k$.

As an example, let's say Alice wants to give money to Bob if he solves a problem
  before a time $k$.
We would like the money to be unspendable from Alice (to ensure Bob he gets the
  money even she changes her mind) until the time $k$.
During this time, if Bobs provide the answer he can claim the money by himself.
After the time $k$, if Bob does not provide an answer, Alice gets her money
  back.

The script at~\ref{eq:notation_sample} describes this set of constraints.
It basically has two branches, the first which requires Bob's signature
  ($\mathcal{S}_B$) and the solution to the problem ($l$); and the second gives
  the money back to Alice after the time $k$ requiring its signature
  ($\mathcal{S}_A$).

\begin{equation} \label{eq:notation_sample}
    (\mathcal{S}_B \wedge l) \vee (\mathcal{S}_A \wedge \uptau_k)
\end{equation}

\subsection{First part: Oracle Selection}

The oracles are a key piece in the protocol, as they get to decide who gets
  the prize money.
The first part of the protocol defines a way to select them in a trustless
  way.
The idea is quite simple, players selects a subset of oracles from a list
  to participate on its bet.
If the list is big enough, selecting elements randomly from it reduces the
  chances that any participants may influence the selection.

\subsubsection{Oracle List Generation}

In order to get a trustworthy list, we define a few key properties:
The list must be decentralized; anybody willing to be an oracle can
  enroll itself; and it must be visible for both players.

As discussed in Section~\ref{subsec:Blockchain}, we already have a public
  distributed database to store information.
We use the blockchain to keep the list of oracles, this provides tampering
  protection, a public database, and a distributed source for the list.
In order to let anybody enroll to be an oracle, the enrollment operation is a
  simple transaction generated by the oracle and sent to the blockchain.
We defined our own string as protocol identification
(``I'm an oracle! Ready to provide data''), but different protocols
  can use different strings to define other types of lists.

\subsubsection{The Oracle Registration Transaction}

\transaction
    {Registration}{oracle previous tx}
    % Inputs
      {Oracle previous tx}{$\alpha$}{$\sigma$}
      \stopinputs
    % Outputs
      {$\nu$}{$\gamma$}
      {$0$}{OP\_RETURN \{ENROLLMENT DATA\}}
      \stopoutputs
    % Caption
      {tx:registration}
      {Oracle Registration.}

In this registration transaction the oracle takes money from an unspent output
  of hers and simply sends all the money to the first output.
The registration happens with the second output. OP\_RETURNS makes this output
  invalid, so nobody can spend it.
This doesn't matter that much, as the value is zero.
But the operation allows us to insert arbitrary data into the blockchain, and it
  is here where we include our predefined string. This string includes the
  oracle's address and its will to participate as oracle in future bets.

Note that there is no required deposit for registration. There is a
  transaction fee, however, which must be paid when submitting the transaction.
We may argue that a higher price to register an oracle will decrease the
  chances of single individual controlling the majority of the list.
If that is the case, increasing the cost by adding a required a unspendable
output does not require any change in the transaction~\ref{tx:registration},
  as the unspendable output already exists.
Adding a deposit spendable by an address will require a new output, but the
  idea remains the same.

When this transaction is submitted to the blockchain, players can look into
  this transaction and recognize it as an oracle registration.

\subsubsection{Compiling the Oracle List}

There are a few parameters the value of which players must agree in order to
  select oracles from the blockchain list.
First they decide the period of time they will consider oracles from\footnote{%
  Time is measured as a range of blocks in the blockchain.}.
Some participants might want to avoid recently registered oracles, as they might
  have a higher chance to be controlled by the other player.
Others might argue that those oracles associated to very old registrations
  are likely to be inactive.
So players may be willing to avoid oracles registered long time ago.

Second, players decide the list to get the oracles from.
In this process, they may want to filter out oracles, for example excluding
  oracles that paid less than $b$ bitcoins on fees at registration time.
Finally they decide the number of oracles to use, also they can decide to
  select a few more than the required oracles, anticipating one or more of
  the selected oracles will not reply to the invitation.

Once the players have agreed on the blocks from where the oracles will be
  selected (and whether some other condition/filter would be required on the
  oracles), both players can compile the same list of available oracles.
Hashing the list and compare the hashes helps the users to be sure they had
  compiled the same list.
This list is the source for selecting the oracles to use, players just need to
  decide which of them to use.

\subsubsection{Oracle Selection Protocol}

If the oracle list is big and there is a cost to register into it, a random
  selection from it decreases the chance for any player to get a possible
  controlled oracle into the final list.

As trust in the other player is not required for this protocol, both players
need to have the certainty the election from the list is random.
In order to achieve this property we use a protocol originally proposed to flip
  coins over the phone \cite{blum1983coin}.
Today this algorithm is mostly known as \textit{coin tossing}, from a subfield of
  cryptography called Secure Multi Party Computation.
Secure Multi Party Computation aims to provide protocols for computing public
  functions and gets its results while participants keep their inputs private.

Roughly speaking, the Coin Tossing protocol we use allow us to get a random bit.
To understand the protocol, let's first consider a simpler protocol.
As neither of the players trust the other to select the bit randomly, both
  players select a bit and they XOR those bits together.
This way, it does not matter how bits were chosen, the result is random.
Clearly, one player's bit must be chosen before knowing the value of  the other,
  otherwise if one bit is known the second one can be selected in order to get
  the desired outcome.
If the players were physically together we would write down the bit in a paper,
  wait for the other player to write his and then reveal both bits and perform
  the XOR\@.
However we would like to run this algorithm through the phone or in this case
  the computer.
The idea is the same, but instead of writing down into a paper, players
  \textit{commit} to the value they just chose randomly by sending to the other
  player a \textit{commitment}.
This commitment binds the player to the value calculated, without revealing it.
Once both players receive the other's commitment, they send the bit they chose.
They check the received value against the previously received commitment, and if
  they match, the protocol outputs the XOR of both bits as the random bit.
Otherwise, a player tried to cheat and the protocol aborts as there is no way to
  calculate a random bit.

If we have a list both players agree with, and we can also produce random bits,
  selecting a number of oracles from the list is a trivial exercise.
After this step, players had decided the oracles to use.
We represent the total number of oracles participating in the protocol by $n$,
  and the required number to decide the bet as $m$, where $\frac{n}{2} < m$.

\section{Bitcoin}
Bitcoin is the first fully distributed cryptocurrency made publicly available,
  it was proposed in 2008 by Satoshi Nakamoto (a pseudonym)
  \cite{nakamoto2008bitcoin}.
The same author shared as open source code a implementation of the protocol in
  January 2009. And the protocol has being running since then.

Nevertheless, Bitcoin is not the first idea of electronic cash.
The idea of electronic cash has been present within the cryptographic community
  since at least 1983, when Chaum \cite{chaum1983blind} proposed a system for
  anonymous payments.
And the attempts kept going for other three decades, hundreds of paper have
  been published with improvements of e-cash schemes\cite{barber2012bitter}.
So, why is Bitcoin so popular and achieved the notority that three decades of
  academic research on the field could not achieve?

Barber et al.\cite{barber2012bitter} suggest a few key points to explain why
  was Bitcoin the first electronic currency to take off.
\begin{enumerate}
\item No central point of trust.
	Bitcoin is a fully distributed system, there are no trusted entities in the
	  system. The only asumption is that the majority of the network participants
	  are honests. Every previous proposal had a central trusted entity for
	  critical tasks, as preventing double spending and coin issuance.
\item Predictable money supply.
	The money supply is minted at a defined and transparent rate, defined from the
	begining of the protocol.
\item Transaction irreversibility.
	Bitcoin transactions quickly become irreversible. This is a big difference with
	  credit cards, where chargebacks has been using largely to commit frauds.
\end{enumerate}
Bitcoin has not stopped to gain massive popularity and attention from the press.
Mainly because its market capitalization (over USD $36\,000\,000\,000$), and some
  illegal activities it has been using to as ransom to retrieve victim's data
  encrypted for malicious software, or as exchange medium in one of the most
  famous online black market, closed in 2013 by the FBI.

  The main technical advance in Bitcoin is its database, the
  \texttt{blockchain}\cite{inventionblockchain}\cite{blockchainmostimportant}.
The blockchain is a distributed database formed by an always growing list of
  blocks, where each block contains the data to be stored, a timestamp and a
  link to a previous block. Its fully distributed nature allows bitcoin to lack
  a central authority.



\subsection{Transaction}\label{subsec:Transaction}
Bitcoin works with accounts where coins can be stored, this accounts are
  identified with an address\footnote{
  In the wire, an address is a 25-byte value, for human consumption we usually
    see it, in its encoded representation of base 58, resulting in a string of
    25-33 characters.}, for this reason some times both words are used
  interchangeably.
The address is not private, and people share theirs when willing to receive
  money.

It represents a hash of a public key. Therefore, the owner of the account is
  however control the private key of the address.
Bitcoin uses Elliptic Curve Digital Signature Algorithm (ECDSA)\footnote{
  ECDSA is a digital signature algorithm using Elliptic Curve
    Cryptography. It is an asymmetric scheme, with a private and public key. In
    bitcoin transactions are secured with a private key signature and validated
    using the public one.} to ensure the owner of an address is the only one able
  to spend its content.
Getting a new address is free, it only requires to generate a random byte string
  and get a ECDSA private key from it. ECDSA allows the public key derivation
  from the private key. Then, by hashing the public key the address is obtained.
Many libraries and most of the bitcoin wallets implement the algorithms to
  generate new addresses.

A transaction is the only way to move bitcoins from one account to other one,
  it is basically a list of accounts where the money is pulled from, the
  inputs.
And the outputs, a list of accounts the bitcoins are going to, a simplified
  view in the figure \ref{fig:simplified_transaction}.

\begin{figure}
	\centering
	\includesvg[width=0.7\columnwidth]{simplified_transaction}
	\caption{Simplified Transaction}
	\label{fig:simplified_transaction}
\end{figure}

There is only one exception to this rule, the miner that builds each block is
  allow to send money to his account from nowhere, this is called the generation
  transaction and its amount is defined in the protocol.
This is the only way bitcoins are generated.

A transaction input points to a previous unspent output and proves it has the
  right to spend that output.
An output contains\footnote{This is a simplification, not every output work this
  way, detailed at subsection \label{subsec:script}.} the address of the account
  is transferring the money to, so any input signed using the private key of
  that address has the right to spend the output.
This implies that the money from an account must be spent in the same amount
  the money was received. If an output of $\$ 10BTC$ is received, when trying
  to spend it, the same amount must be spent. If willing to spend just a
  portion, a second output is created and send to the same account.

\subsection{Blockchain} \label{subsec:Blockchain}
It works as the bitcoin's ledger, it keeps record of all
  transactions and coin generation that had ever taken place in the protocol.
It is completely distributed and public, anybody can participate and get a
  copy of it.
This makes simple to prevent double spending and be sure the received coins are
  valid, as anybody can examine where each coin came from.

As any other distributed system, the blockchain must resolve the consesus
  problem \cite{fischer1983consensus}. Get all the participants to agree on
  the data. This is a fundamental problem to any distributed system. In the
  the blockchain anybody with an internet connection can be part of the
  protocol, so solving this problem is quite challenging. Some authors argue
  the blockchain is the first practical solution to the Byzantine Consensus
  problem \cite{miller2014anonymous} \cite{sun2014solving}.

Proof of work is the algorithm used by the bitcoin blockchain to seek
  consensus. Each entity trying to add data to the database must prove it
  has done some required work. This algotithms was designed originally to
  fight the email spam, by requiring the sender of an email to prove a small
  work was done in order to send the email\cite{dwork1992pricing}.
It works by using a hard to calculate, but easy to check function. This
  way the receiver or the mail server can easily check if the sender did
  the required work, however this work was much harder. The difficulty of
  a work is defined by the amount of computational power required to get
  it done.

The atomical piece in the blockchain is the block. Each valid block carries
  transactions of the protocol and a proof of work. So every entity trying to
  get a valid block into the database need to collect transactions and solve
  the puzzle to get a valid proof of work for its block.
This process is called mining, therefore the entities trying to get a valid
  block are called miners. A block is linked to the previous one, as show by the
  figure \ref{fig:block_links}.

\begin{figure}
	\centering
	\def\svgwidth{\columnwidth}
	\includesvg{block_links}
	\caption{Blocks linked to each other in the blockchain.}
	\label{fig:block_links}
\end{figure}

The mining process is like playing the lottery, tickets are distributed  among
  every miner until someone gets the winner one. The number of tickets each
  miner gets is proportional to the work he is doing, so a miner doing more work
  will get a bigger chance to win the lottery and mine a block. However any miner
  can win.

Of course, in the real implementation there are no tickets issued to the
  miners.
Proof of work consists in building a block with a hash under a threshold value,
  so the miners should reorder and change the block until the hash fulfill the
  requirement.
There is not a known algorithm to do this in a better way than
  brute force, so the only method to get a hash that mets the criteria is to try
  with different block configurations, there are also some bytes of nonce, a
  timestamp and transactions to be changes to get different hashes.

Once block is produced, all the others miners need to delete the transactions
  added by the block from the one they are building and update the link to the
  new last block. And they start to mine a new block.
By design a block must be produced every 10 minutes, so the work required to
  mine a block is a ajusted periodically to met this goal.

The structure of a Bitcoin block is show in the figure \ref{fig:block_pow}, the
  fields with the gray background represents the block header, the data hashed
  to get the block's hash.
The transactions are indirectly hashed in the Merkle Root\footnote{A
  \texttt{Merkle Tree} is a tree in which each non leaf node is labeled with
  the hash of its children's labels. In the block each transaction is mapped
  into a tree leaf. So the root of this tree hashes all the transactions}.

  \begin{figure}[ht]
	\centering
	\includesvg[width=0.8\columnwidth]{block_pow}
	\caption{Block Structure}
	\label{fig:block_pow}
\end{figure}

As expected in a protocol with many participants, there are times were more
  than one block is generated with the same parent (figure
  \ref{fig:chain_fork}), this is call a fork.

\begin{figure}
	\centering
	\def\svgwidth{\columnwidth}
	\includesvg{chain_fork}
	\caption{A fork in the blockchain.}
	\label{fig:chain_fork}
\end{figure}

In order to achieve consensus, the protocol determines that the chain with
  more work\footnote{The amount of work in a chain is the sum of the difficulty
  of every block on it.} on it is the active chain.
So when a fork happen there are two active chains, while having a non unique
  active chain miners will try to mine in any of the candidates with the same
  work.
A block mined on one of the branches will decide which is the active one
  because it adds more work to the chain. However the situation that originated
  the fork can repeat itself and prevent to have one consensus branch, this is
  very unlikely\cite{decker2013information} to happen during a long time.

The chain structure gives a chronological order to the transactions in the
  protocol, so it makes clear to check if a transaction is valid.
Any participant willing to probe the validity of a given transaction needs
  to evaluate the script (see section \ref{subsec:script}), and  check the block
  where the output being spend is stored up to the current block and see if the
  money was already spent in a different transaction.

  \subsection{Script} \label{subsec:script}

When sending money, there is a little more than we saw at section
  \ref{subsec:Transaction}. In an input (figure \ref{fig:input}) there is more
  than a signature, and at each output (figure \ref{fig:output}) also more than
  an address.

  \begin{figure}[ht]
	\centering
	\includesvg[width=0.8\columnwidth]{input}
	\caption{Wire format of an Input.}
	\label{fig:input}
\end{figure}

\begin{figure}[ht]
	\centering
	\includesvg[width=0.8\columnwidth]{output}
	\caption{Wire format of an Output.}
	\label{fig:output}
\end{figure}

An output does not send money to a given address, but defines how the money can
  be spent. Currently there are two formats in use. The most used is called
  ``Pay To Public Key Hash'' (P2PKH)\footnote{The key hash is the address of an
  account}. And ``Pay To Script Hash'' (P2SH).

As the figure \ref{fig:output} shows, the output have a script on its wire
  representation, this script is written in a small stack based language.
It is read from left to right and it is purposefully not Turing-complete.
The script is evaluated using the scriptSig as input. If the transaction willing
  to spend this output provides a valid\footnote{A script is considered valid
  if after its execution the value in the top of the stack is True.} scriptSig,
  the output is available to be spend. This is how a P2PKH script looks like:

\begin{center}
	  \begin{tabular}{|c|}
		  \texttt{OP\_DUP OP\_HASH160 <pubKeyHash> OP\_EQUALVERIFY OP\_CHECKSIG}
     \end{tabular}
\end{center}

  It receives two values as input:  \lstinline{<pubKeyHash>} and
  \lstinline{<sig>}. And the execution is explained in the table \ref{tab:p2pkh_exec}.

	\begin{table}[]
		\small
		\caption{Script evaluation to check a P2PKH transaction.}
		\label{tab:p2pkh_exec}
		\begin{tabularx}{\textwidth}{| c | X |}
			\hline
				\thead{Stack} & \thead{Script} \\
			\hline
			\multicolumn{2}{|c|}{\textit{Constants from scriptSig are copied to the stack.}} \\
			\hline
			\makecell{<pubKey>\\<sig>} & OP\_DUP \footnotesize{OP\_HASH160 <pubKeyHash> OP\_EQUALVERIFY OP\_CHECKSIG} \\
			\hline
			\multicolumn{2}{|c|}{\textit{OP\_DUP copies the top element from the stack.}} \\
			\hline
			\makecell{<pubKey> \\ <pubKey> \\ <sig>} & OP\_HASH160 \footnotesize{<pubKeyHash> OP\_EQUALVERIFY OP\_CHECKSIG} \\
			\hline
			\multicolumn{2}{|c|}{\textit{The hash of the top element is calculated.}} \\
			\hline
			\makecell{H(<pubKey>) \\ <pubKey> \\ <sig>} & <pubKeyHash> \footnotesize{OP\_EQUALVERIFY OP\_CHECKSIG} \\
			\hline
			\multicolumn{2}{|c|}{\textit{The destination address is moved to the stack.}} \\
			\hline
			\makecell{<pubKeyHash> \\ H(<pubKey>) \\ <pubKey> \\ <sig>} & OP\_EQUALVERIFY \footnotesize{OP\_CHECKSIG} \\
			\hline
			\multicolumn{2}{|c|}{\textit{The destination address is compared with the Hash of the Public Key (PK) provided by the}} \\
			\multicolumn{2}{|c|}{\textit{sig Script. This check the provided Public Key is the one from the intended receiver.}} \\
			\hline
			\makecell{<pubKey> \\ <sig>} & OP\_CHECKSIG \\
			\hline
			\multicolumn{2}{|c|}{\textit{Using the already verified PK, the script checks the transaction was signed using the}} \\
			\multicolumn{2}{|c|}{\textit{corresponding Private Key. This step secures the transaction from tampering an proves it was}} \\
			\multicolumn{2}{|c|}{\textit{sent by the private Key controller.}} \\
			\hline
			\makecell{True} & \\
			\hline
		\end{tabularx}
	\end{table}

The scriptPubKey in a pay to script hash transaction is even simpler:
\begin{center}
	\begin{tabular}{|c|}
		\texttt{OP\_HASH160 <scriptHash> OP\_EQUAL}
	\end{tabular}
\end{center}
Whis script is pretty simple, it takes the first element of the stack,
  calculates its hash and compares it with '<scriptHash>'. The first
  element in the stack is however a complete script, and after checking
  it hashes to the expected scriptHash, it will be evaluated with its
  required input. This implies the scriptSig now holds the script and
  its signature:

\begin{center}
	\begin{tabular}{|c|}
		\texttt{<sig> >script>}
	\end{tabular}
	% \caption*{P2SH sigScript.}
\end{center}


  A execution of a sample P2SH is show in the table \ref{tab:p2sh_exec}.

	\begin{table}[]
		\small
		\caption{Script evaluation of a P2SH transaction.}
		\label{tab:p2sh_exec}
		\begin{tabularx}{\textwidth}{| c | X |}
			\hline
				\thead{Stack} & \thead{Script} \\
			\hline
			\multicolumn{2}{|c|}{\textit{The serialized script and its input are copied to the stack.}} \\
			\hline
			\makecell{\string{<pubkey> OP\_CHECKSIG\string} \\ <sig> } & OP\_HASH160 \footnotesize{<scriptHash> OP\_EQUAL} \\
			\hline
			\multicolumn{2}{|c|}{\textit{The serialized script hash is calculated.}} \\
			\hline
			\makecell{H(\string{<pubkey> OP\_CHECKSIG\string}) \\ <sig>} & <pubkeyHash> \footnotesize{OP\_EQUAL} \\
			\hline
			\multicolumn{2}{|c|}{\textit{The expected hash is pushed to the stack.}} \\
			\hline
			% \makecell{asdas} & dqwdeq \\
			\makecell{<pubKeyHash> \\ H(\string{<pubkey> OP\_CHECKSIG\string}) \\ <sig>} & OP\_EQUAL \\
			\hline
			\multicolumn{2}{|c|}{\textit{Then the hashes are compared, and if they match, the script is deserialized and evaluated.}} \\
			\hline
			\makecell{<sig>} & <pubkey> \footnotesize{OP\_CHECKSIG} \\
			\hline
			\multicolumn{2}{|c|}{\textit{The public key is pushed to the stack.}} \\
			\hline
			\makecell{<pubKey> \\ <sig>} & OP\_CHECKSIG \\
			\hline
			\multicolumn{2}{|c|}{\textit{The provided signature is validated using the public key.}} \\
			\hline
			\makecell{True} & \\
			\hline
		\end{tabularx}
	\end{table}

A P2SH transaction allows different conditions to redeems its outputs,
  a complete list of the operations supported by the Bitcoin scripting language
  can be found at the Bitcoin wiki: \url{https://en.bitcoin.it/wiki/Script}.

% The blockchain does not introduce a new primitive or idea to solve all of the
  % mentioned problems, it does use existing tools in an innovative way to.
% To keep a consistent history the blocks are linked using the hash of the
  % previous block, this prevents tamper on past data.




% As it is public, every transaction can be verified by any protocol participant.


  % The blockchain is  a chain of blocks were each of them keeps a link
% to the previou
  % also fully distributed. In bitcoin



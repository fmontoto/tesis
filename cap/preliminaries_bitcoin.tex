\section{Bitcoin}
Bitcoin is the first fully distributed cryptocurrency made publicly available,
  proposed in 2008 by Satoshi Nakamoto (a pseudonym) \cite{nakamoto2008bitcoin}.
The same author shared as open source code implementation of the protocol in
  January 2009, and it has been running ever since.

Nevertheless as it was mentioned in the previous section, Bitcoin is not the
  first idea of electronic cash.
The idea of electronic cash has been present within the cryptographic community
  since at least 1983 \cite{chaum1983blind}.
And there were attempts for another three decades, and hundreds of papers
  published with improvements of e-cash schemes\cite{barber2012bitter}.
So, why is Bitcoin so popular and why has it achieved the notoriety that three
  decades of academic research on the field could not achieve?

Barber et al. \cite{barber2012bitter} suggest a few key points to explain why
  Bitcoin was the first electronic currency to take off.
\begin{enumerate}
\item No central point of trust.
	Bitcoin is a fully distributed system, there are no trusted entities in the
	  system. The only assumption is that the majority of the network participants
	  are honest. Every previous proposal had a central trusted entity for
	  critical tasks, as preventing double spending and coin issuance.
\item Predictable money supply.
	The money supply is minted at a defined and transparent rate, defined from
	  the beginning of the protocol.
\item Transaction irreversibility.
	Bitcoin transactions quickly become irreversible. This is a big difference
	  with credit cards, where chargebacks have been used largely to commit
	  fraud.
\end{enumerate}

  The main technical advance in Bitcoin is its database, the
  \texttt{blockchain} \cite{inventionblockchain,blockchainmostimportant}.
The blockchain is a distributed database formed by an always growing list of
  blocks, where each block contains the data to be stored, a timestamp and a
  link to a previous block. Its fully distributed nature allows bitcoin to lack
  a central authority.

\subsection{Transactions}\label{subsec:Transaction}
Bitcoin works with accounts where coins are stored, these accounts are
  identified with an address\footnote{In the implementation format, an address
    is a 25-byte value, yet for human consumption we usually see it in its
    encoded representation of base 58, resulting in a string of 25-33
    characters.}, for this reason sometimes account and address are used
    interchangeably.
The address is not private, and people share their accounts when willing to
  receive money.

The address represents a hash of a public key. The owner of the account is
  whoever controls the private key associated to the address.
Bitcoin uses Elliptic Curve Digital Signature Algorithm (ECDSA)\footnote{%
  ECDSA is a digital signature algorithm using Elliptic Curve
    Cryptography. It is an asymmetric scheme, with a private and public key.
    Bitcoin transactions are secured with a private key signature and validated
    using the public one.} to ensure the owner of an address is the only one able
  to spend its content.
Getting a new address is free, it only requires one to generate a random byte
  string and get a ECDSA private key from it. ECDSA allows the public key
  derivation from the private key.
By hashing the public key the address is then obtained.
Many libraries and most of the bitcoin wallets implement the algorithms to
  generate new addresses.

A transaction is the only way to move bitcoins from one account to another,
  it is basically two lists:
  a list of accounts where the money is pulled from, called inputs; and a list
  of accounts where the bitcoins are going to, a simplified
  view is illustrated in the figure~\ref{fig:simplified_transaction}.

\begin{figure}
	\centering
	\includesvg[width=0.7\columnwidth]{simplified_transaction}
	\caption{Simplified Transaction}
	\label{fig:simplified_transaction}
\end{figure}

There is only one exception to this rule; the miner that builds each block is
  allowed to create a transaction without inputs and send money to his account.
The details of this special transaction, called generation transaction, are
  defined in the protocol.
Any attempt to generate more than the defined coins from the miner will make
  this transaction invalid.
The amount of coin generated by each block is set to decrease geometrically
  each $210\,000$ blocks by a 50\%.
Until it reaches the maximum supply of 21 Million bitcoins.
Then, no more coins will be generated.

A transaction input points to a previous unspent output and proves it has the
  right to spend that output.
An output contains the address of the account it is transferring the money to,
  so any input signed using the private key of that address has the right to
  spend the output\footnote{This is a simplification, not every output works
  this way. Details are in Section~\ref{subsec:script}.}.
This implies that the money from an account must be spent in the same amount
  the money was received. There is no way to spend just a fraction of the money
  received in a previous output. If an output of $\$ 10BTC$ is received, when
  trying to spend it, the same amount must be spent. If willing to spend just a
  portion, a second output is created and sent to the same account.

\subsection{Blockchain} \label{subsec:Blockchain}
It works as the bitcoin's ledger keeping record of all transactions and coin
  generation that had ever taken place in the protocol.
It is completely distributed, public, and anybody can participate and get a
  copy of it.
This makes it simple to prevent double spending while being sure the received
  coins are valid, as anybody can examine where each coin came from.

As any other distributed system, the blockchain must resolve the consensus
  problem \cite{fischer1983consensus}. Get all the participants to agree on
  the data. This is a fundamental problem to any distributed system. In the
  blockchain anybody with an internet connection can be part of the
  protocol, so solving this problem is quite challenging. Some authors argue
  that the blockchain is the first practical solution to the Byzantine Consensus
  problem \cite{miller2014anonymous,sun2014solving}.

Proof of work is the algorithm used by the bitcoin blockchain to seek
  consensus. Each entity trying to add data to the database must prove it
  has done some required work. This algorithm was designed originally to fight
  email spam by requiring the sender of an email to prove that a small job was
  done in order to send the email \cite{dwork1992pricing}.
It works by using a hard to calculate, but easy to check function. This
  way the receiver or the mail server can easily check if the sender did
  the required work.
However the work of the sender was much harder.
The difficulty of a particular work is defined by the amount of computational
  power required to get it done.

The atomical piece in the blockchain is the block. Each valid block carries
  transactions of the protocol and a proof of work. Therefore every entity
  trying to get a valid block into the database needs to collect transactions
  and solve the puzzle to get a valid proof of work for its block.
This process is called mining, therefore the entities trying to get a valid
  block are called miners. A block is linked to the previous one, as show in the
  figure~\ref{fig:block_links}.

\begin{figure}
	\centering
	\def\svgwidth{\columnwidth}
	\includesvg{block_links}
	\caption{Blocks linked to each other in the blockchain.}
	\label{fig:block_links}
\end{figure}

The mining process is like playing the lottery: tickets are distributed  among
  every miner until someone gets the winning one. The number of tickets each
  miner gets is proportional to the work he/she is doing, so a miner doing more
  work will have a bigger chance at winning the lottery and mine a block.
However, in principle any miner can win.

Of course, in the real implementation there are no tickets issued to the
  miners.
Proof of work consists in building a block with a hash under a threshold value,
  so the miners should reorder and change the block until the hash fulfills the
  requirement.
There is no known algorithm to do this in a better way than brute force, so the
  only method to get a hash that mets the criteria is to try with different
  block configurations. In the block there are also some bytes of nonce, a
  timestamp and transactions to be changed to get different hashes.

Once block is produced, all the other miners need to delete the transactions
  added by the block from the one they are building and update the link to the
  new last block. And they start to mine a new block.
By design a block must be produced every 10 minutes, so the work required to
  mine a block is adjusted periodically to meet this goal.

The structure of a Bitcoin block is shown in figure~\ref{fig:block_pow}, the
  fields with the gray background represents the block header, the data hashed
  to get the block's hash.
The transactions are indirectly hashed in the Merkle Root\footnote{A
  \texttt{Merkle Tree} is a tree in which each non leaf node is labeled with
  the hash of its children's labels. In the block each transaction is mapped
  into a tree leaf. So the root of this tree hashes all the transactions.}.

  \begin{figure}[ht]
	\centering
	\includesvg[width=0.8\columnwidth]{block_pow}
	\caption{Block Structure}
	\label{fig:block_pow}
\end{figure}

As expected in a protocol with many participants, there are times where more
  than one block is generated with the same parent
  (figure~\ref{fig:chain_fork}). This is called ``fork''.

\begin{figure}
	\centering
	\def\svgwidth{0.7\columnwidth}
	\includesvg{chain_fork}
	\caption{A fork in the blockchain.}
	\label{fig:chain_fork}
\end{figure}

In order to achieve consensus, the protocol determines that the chain with
  more work\footnote{The amount of work in a chain is the sum of the difficulty
  of every block on it.} on it is the active chain.
So when a fork happens there are two active chains, while having a non unique
  active chain miners will try to mine in any of the candidates with the same
  work.
A block mined on one of the branches will decide which is the active one
  because it adds more work to the chain. However the situation that originated
  the fork can repeat itself and prevent having one consensus branch, which is
  very unlikely \cite{decker2013information} to happen during a long time.

The chain structure gives a chronological order to the transactions in the
  protocol, so it makes it easy to check if a transaction is valid.
Any participant willing to probe the validity of a given transaction needs
  to evaluate the script (see Section~\ref{subsec:script}), and  check the block
  where the output being spent is stored up to the current block and see if the
  money was already spent in a different transaction.

  \subsection{Script} \label{subsec:script}

When sending money, there are more details than we have discussed at
  Section~\ref{subsec:Transaction}. In an input (figure~\ref{fig:input}) there
  is more than a signature, and at each output (figure~\ref{fig:output}) there
  are also more than one address.

\begin{figure}[ht]
  \centering
  \includesvg[width=0.8\columnwidth]{input}
  \caption[Wire format of an Input.]{Wire format of an Input.
             The first two fields specify the output to be spent.
             The first one is the hash of the transaction containing it, and the
               second its index on it.
             The next two fields define the input script, commonly known as
               scriptSig.
             To be a valid input the script in the output being spent must
               evaluate to true using this script as parameter.
             The last field, sequence\_no, is used to lock executions based on
             the age of the output being spent.
         }
  \label{fig:input}
\end{figure}

\begin{figure}[ht]
  \centering
  \includesvg[width=0.8\columnwidth]{output}
  \caption[Wire format of an Output]{Wire format of an Output.
           The first field is the amount of coins this output holds.
           The second field specifies the length of the script.
           And the third field is the script required to spend this output,
             it contains a sequence of operations in the bitcoin scriptin
             language.
           This output can be spent for anybody able to provide an input to this
             script such that after evaluating it, the stack finishes with a
             true value in the top.
             }
  \label{fig:output}
\end{figure}

An output does not send money to a given address, but defines how the money can
  be spent. Currently there are two formats in use. The most used is called
  ``Pay To Public Key Hash'' (P2PKH)\footnote{The key hash is the address of an
  account.}. The other is called ``Pay To Script Hash'' (P2SH).

As figure~\ref{fig:output} shows, the output has a script on its wire
  representation.
This script is written in a small stack based language.
It is read from left to right and it is purposefully not Turing-complete.
The script is evaluated using the scriptSig as input. If the transaction willing
  to spend this output provides a valid scriptSig\footnote{A script is
  considered valid if after its execution the value in the top of the stack is
  True.}, the output is available to be spent. This is how a P2PKH script looks
  like:

\begin{center}
  \begin{tabular}{|c|}
    \texttt{OP\_DUP OP\_HASH160 <pubKeyHash> OP\_EQUALVERIFY OP\_CHECKSIG}
  \end{tabular}
\end{center}

It receives two values as input:  \lstinline{<pubKey>} and \lstinline{<sig>}.
It will first hash the public key and compare it with the expected address and
  then verify the provided signature.
Detailed execution is provided in table~\ref{tab:p2pkh_exec}.

\begin{table}[tbp]
  \small
    \begin{tabularx}{\textwidth}{| c | X |}
    \hline
	    \thead{Stack} & \thead{Script} \\
	\hline
      \multicolumn{2}{|l|}{\textbf{Step 1: }\textit{%
          Constants from scriptSig are copied to the stack.}} \\
    \hline
	  \makecell{<pubKey>\\<sig>} & OP\_DUP \footnotesize{%
          OP\_HASH160 <pubKeyHash> OP\_EQUALVERIFY OP\_CHECKSIG} \\
    \hline
	  \multicolumn{2}{|l|}{\textbf{Step 2: }\textit{%
	      OP\_DUP copies the top element from the stack.}} \\
    \hline
      \makecell{<pubKey> \\ <pubKey> \\ <sig>} & OP\_HASH160 \footnotesize{%
          <pubKeyHash> OP\_EQUALVERIFY OP\_CHECKSIG} \\
	\hline
      \multicolumn{2}{|l|}{\textbf{Step 3: }\textit{%
          The hash of the top element is calculated.}} \\
    \hline
	  \makecell{H(<pubKey>) \\ <pubKey> \\ <sig>} & <pubKeyHash> \footnotesize{%
          OP\_EQUALVERIFY OP\_CHECKSIG} \\
    \hline
	  \multicolumn{2}{|l|}{\textbf{Step 4: }\textit{%
	      The destination address is moved to the stack.}} \\
	\hline
	  \makecell{<pubKeyHash> \\ H(<pubKey>) \\ <pubKey> \\ <sig>} &%
	      OP\_EQUALVERIFY \footnotesize{OP\_CHECKSIG} \\
	\hline
	  \multicolumn{2}{|l|}{\textbf{Step 5: }\textit{%
	      The destination address is compared with the Hash of the %
          Public Key (PK) provided by}} \\
	  \multicolumn{2}{|l|}{\textit{the sig Script. This checks that the provided %
	      Public Key is the one from the intended receiver.}} \\
	\hline
	  \makecell{<pubKey> \\ <sig>} & OP\_CHECKSIG \\
	\hline
	  \multicolumn{2}{|l|}{\textbf{Step 6: }\textit{%
	      Using the already verified PK, the script checks that the transaction was %
          signed using the}} \\
	  \multicolumn{2}{|l|}{\textit{corresponding Private Key. This step %
	      secures the transaction from tampering an proves it was}} \\
	  \multicolumn{2}{|l|}{\textit{sent by the private Key controller.}} \\
	\hline
	  \makecell{True} & \\
	\hline
    \end{tabularx}
    \caption{Script evaluation to check a P2PKH transaction.}
    \label{tab:p2pkh_exec}
  % small
\end{table}

The script in a pay to script hash (P2SH) transaction is even simpler:
\begin{center}
	\begin{tabular}{|c|}
		\texttt{OP\_HASH160 <scriptHash> OP\_EQUAL}
	\end{tabular}
\end{center}
This script is pretty simple, it takes the first element of the stack,
  calculates its hash and compares it with `<scriptHash>'. The first
  element in the stack is however a complete script, and after checking
  it hashes to the expected scriptHash, this element will be evaluated with its
  required input. This implies the scriptSig now holds the script and
  its signature:

\begin{center}
	\begin{tabular}{|c|}
		\texttt{<sig> <script>}
	\end{tabular}
	% \caption*{P2SH sigScript.}
\end{center}


  Execution of a sample P2SH is shown in table~\ref{tab:p2sh_exec}.

\begin{table}[tbp]
  \small
	\begin{tabularx}{\textwidth}{| c | X |}
	  \hline
	    \thead{Stack} & \thead{Script} \\
	  \hline
	  \multicolumn{2}{|c|}{\textbf{Step 1: }\textit{%
	      The serialized script and its input are copied to the stack.}} \\
	  \hline
		\makecell{\{<pubkey> OP\_CHECKSIG\} \\ <sig> } & %
	      OP\_HASH160 \footnotesize{<scriptHash> OP\_EQUAL} \\
	  \hline
		\multicolumn{2}{|l|}{\textbf{Step 2: }\textit{%
		  The serialized script hash is calculated.}} \\
      \hline
		\makecell{H(\{<pubkey> OP\_CHECKSIG\}) \\ <sig>} & %
	      <pubkeyHash> \footnotesize{OP\_EQUAL} \\
	  \hline
		\multicolumn{2}{|l|}{\textbf{Step 3: }\textit{%
		  The expected hash is pushed to the stack.}} \\
	  \hline
		\makecell{<pubKeyHash> \\ %
		    H(\{<pubkey> OP\_CHECKSIG\}) \\ <sig>} & OP\_EQUAL \\
	  \hline
		\multicolumn{2}{|l|}{\textbf{Step 4: }\textit{%
		    Hashes are compared, and if they match, the script is deserialized and evaluated.}} \\
      \hline
	    \makecell{<sig>} & <pubkey> \footnotesize{OP\_CHECKSIG} \\
	  \hline
	    \multicolumn{2}{|l|}{\textbf{Step 5: }\textit{%
	      The public key is pushed to the stack.}} \\
	  \hline
		\makecell{<pubkey> \\ <sig>} & OP\_CHECKSIG \\
	  \hline
		\multicolumn{2}{|l|}{\textbf{Step 6: }\textit{%
		    The provided signature is validated using the public key <pubkey>.}} \\
	  \hline
	    \makecell{True} & \\
	  \hline
	\end{tabularx}
    \caption{Script evaluation of a P2SH transaction.}
	\label{tab:p2sh_exec}
  % \end small
\end{table}

A P2SH transaction allows different conditions to redeem its outputs.
Even bitcoin script language is not Turing-complete, it implements around two
  hundred functions.
It implements basic flow control, as \lstinline{IF}, \lstinline{ELSE}, etc.;
  stack operations to delete, swap, duplicate, etc. elements from the stack;
  arithmetic operations to operate 32-bit integers; cryptographic operations as
  hashing, and signature verification.
We will add an explanation of operations used in this work as we mention them.
An extensive list of the operations supported by the bitcoin scripting language
  can be found at the Bitcoin wiki: \url{https://en.bitcoin.it/wiki/Script}.

\section{Bitcoin}
Bitcoin is the first fully distributed cryptocurrency made publicly available,
  proposed in 2008 by Satoshi Nakamoto (a pseudonym) \cite{nakamoto2008bitcoin}.
The same author shared as open source code a implementation of the protocol in
  January 2009. And the protocol has been running ever since.

Nevertheless, Bitcoin is not the first idea of electronic cash.
The idea of electronic cash has been present within the cryptographic community
  since at least 1983, when Chaum \cite{chaum1983blind} proposed a system for
  anonymous payments.
And the attempts kept going for another three decades, amd  hundreds of papers
  have been published with improvements of e-cash schemes
  \cite{barber2012bitter}.
Why is Bitcoin so popular and why has it achieved the notority that three
  decades of academic research on the field could not achieve?

Barber et al.\cite{barber2012bitter} suggest a few key points to explain why
  Bitcoin was the first electronic currency to take off.
\begin{enumerate}
\item No central point of trust.
	Bitcoin is a fully distributed system, there are no trusted entities in the
	  system. The only asumption is that the majority of the network participants
	  are honest. Every previous proposal had a central trusted entity for
	  critical tasks, as preventing double spending and coin issuance.
\item Predictable money supply.
	The money supply is minted at a defined and transparent rate, defined from
	  the begining of the protocol.
\item Transaction irreversibility.
	Bitcoin transactions quickly become irreversible. This is a big difference
	  with credit cards, where chargebacks have been used largely to commit
	  fraud.
\end{enumerate}

  The main technical advance in Bitcoin is its database, the
  \texttt{blockchain} \cite{inventionblockchain}\cite{blockchainmostimportant}.
The blockchain is a distributed database formed by an always growing list of
  blocks, where each block contains the data to be stored, a timestamp and a
  link to a previous block. Its fully distributed nature allows bitcoin to lack
  a central authority.

\subsection{Transaction}\label{subsec:Transaction}
Bitcoin works with accounts where coins are stored, these accounts are
  identified with an address\footnote{In the wire, an address is a 25-byte
    value, for human consumption we usually see it in its encoded representation
    of base 58, resulting in a string of 25-33 characters.}, for this reason
  sometimes both words are used interchangeably.
The address is not private, and people share theirs when willing to receive
  money.

The address represents a hash of a public key. Therefore, the owner of the
  account is however control the private key of the address.
Bitcoin uses Elliptic Curve Digital Signature Algorithm (ECDSA)\footnote{%
  ECDSA is a digital signature algorithm using Elliptic Curve
    Cryptography. It is an asymmetric scheme, with a private and public key.
    Bitcoin transactions are secured with a private key signature and validated
    using the public one.} to ensure the owner of an address is the only one able
  to spend its content.
Getting a new address is free, it only requires one to generate a random byte
  string and get a ECDSA private key from it. ECDSA allows the public key
  derivation from the private key.
By hashing the public key the address is then obtained.
Many libraries and most of the bitcoin wallets implement the algorithms to
  generate new addresses.

A transaction is the only way to move bitcoins from one account to other one,
  it is basically two lists:
  a list of accounts where the money is pulled from, called inputs; and a list
  of accounts where the the bitcoins are going to, a simplified
  view in the figure~\ref{fig:simplified_transaction}.

\begin{figure}
	\centering
	\includesvg[width=0.7\columnwidth]{simplified_transaction}
	\caption{Simplified Transaction}
	\label{fig:simplified_transaction}
\end{figure}

There is only one exception to this rule; the miner that builds each block is
  allowed to create a transaction without intputs and send money to his account.
This especial transaction called generation transaction and its amount is
  defined in the protocol.
This is the only way bitcoins are generated.

A transaction input points to a previous unspent output and proves it has the
  right to spend that output.
An output contains\footnote{This is a simplification, not every output works
  this way. Details are in subsection~\ref{subsec:script}.} the address of the
  account it is transferring the money to, so any input signed using the private
  key of that address has the right to spend the output.
This implies that the money from an account must be spent in the same amount
  the money was received. There is no way to spend just a fraction of the money
  received in a previous output. If an output of $\$ 10BTC$ is received, when
  trying to spend it, the same amount must be spent. If willing to spend just a
  portion, a second output is created and sent to the same account.

\subsection{Blockchain} \label{subsec:Blockchain}
It works as the bitcoin's ledger keeping record of all transactions and coin
  generation that had ever taken place in the protocol.
It is completely distributed, public, and anybody can participate and get a
  copy of it.
This makes it simple to prevent double spending while being sure the received
  coins are valid, as anybody can examine where each coin came from.

As any other distributed system, the blockchain must resolve the consesus
  problem \cite{fischer1983consensus}. Get all the participants to agree on
  the data. This is a fundamental problem to any distributed system. In the
  the blockchain anybody with an internet connection can be part of the
  protocol, so solving this problem is quite challenging. Some authors argue
  that the blockchain is the first practical solution to the Byzantine Consensus
  problem \cite{miller2014anonymous} \cite{sun2014solving}.

Proof of work is the algorithm used by the bitcoin blockchain to seek
  consensus. Each entity trying to add data to the database must prove it
  has done some required work. This algotithm was designed originally to fight
  email spam by requiring the sender of an email to prove that a small job was
  done in order to send the email \cite{dwork1992pricing}.
It works by using a hard to calculate, but easy to check function. This
  way the receiver or the mail server can easily check if the sender did
  the required work. However this work was much harder. The difficulty of
  particular work is defined by the amount of computational power required to
  get it done.

The atomical piece in the blockchain is the block. Each valid block carries
  transactions of the protocol and a proof of work. Therefore every entity
  trying to get a valid block into the database needs to collect transactions
  and solve the puzzle to get a valid proof of work for its block.
This process is called mining, therefore the entities trying to get a valid
  block are called miners. A block is linked to the previous one, as show in the
  figure~\ref{fig:block_links}.

\begin{figure}
	\centering
	\def\svgwidth{\columnwidth}
	\includesvg{block_links}
	\caption{Blocks linked to each other in the blockchain.}
	\label{fig:block_links}
\end{figure}

The mining process is like playing the lottery: tickets are distributed  among
  every miner until someone gets the winning one. The number of tickets each
  miner gets is proportional to the work he/she is doing, so a miner doing more
  work will have a bigger chance at winning the lottery and mine a block.
However, any miner can win.

Of course, in the real implementation there are no tickets issued to the
  miners.
Proof of work consists in building a block with a hash under a threshold value,
  so the miners should reorder and change the block until the hash fulfills the
  requirement.
There is no known algorithm to do this in a better way than brute force, so the
  only method to get a hash that mets the criteria is to try with different
  block configurations. In the block there are also some bytes of nonce, a
  timestamp and transactions to be changed to get different hashes.

Once block is produced, all the other miners need to delete the transactions
  added by the block from the one they are building and update the link to the
  new last block. And they start to mine a new block.
By design a block must be produced every 10 minutes, so the work required to
  mine a block is adjusted periodically to meet this goal.

The structure of a Bitcoin block is shown in figure~\ref{fig:block_pow}, the
  fields with the gray background represents the block header, the data hashed
  to get the block's hash.
The transactions are indirectly hashed in the Merkle Root\footnote{A
  \texttt{Merkle Tree} is a tree in which each non leaf node is labeled with
  the hash of its children's labels. In the block each transaction is mapped
  into a tree leaf. So the root of this tree hashes all the transactions.}.

  \begin{figure}[ht]
	\centering
	\includesvg[width=0.8\columnwidth]{block_pow}
	\caption{Block Structure}
	\label{fig:block_pow}
\end{figure}

As expected in a protocol with many participants, there are times where more
  than one block is generated with the same parent
  (figure~\ref{fig:chain_fork}). This is called ``fork''.

\begin{figure}
	\centering
	\def\svgwidth{0.7\columnwidth}
	\includesvg{chain_fork}
	\caption{A fork in the blockchain.}
	\label{fig:chain_fork}
\end{figure}

In order to achieve consensus, the protocol determines that the chain with
  more work\footnote{The amount of work in a chain is the sum of the difficulty
  of every block on it.} on it is the active chain.
So when a fork happens there are two active chains, while having a non unique
  active chain miners will try to mine in any of the candidates with the same
  work.
A block mined on one of the branches will decide which is the active one
  because it adds more work to the chain. However the situation that originated
  the fork can repeat itself and prevent having one consensus branch, which is
  very unlikely \cite{decker2013information} to happen during a long time.

The chain structure gives a chronological order to the transactions in the
  protocol, so it makes easy to check if a transaction is valid.
Any participant willing to probe the validity of a given transaction needs
  to evaluate the script (see section~\ref{subsec:script}), and  check the block
  where the output being spent is stored up to the current block and see if the
  money was already spent in a different transaction.

  \subsection{Script} \label{subsec:script}

When sending money, there is a little more than we saw at
  section~\ref{subsec:Transaction}. In an input (figure~\ref{fig:input}) there
  is more than a signature, and at each output (figure~\ref{fig:output}) also
  more than an address.

\begin{figure}[ht]
  \centering
  \includesvg[width=0.8\columnwidth]{input}
  \caption{Wire format of an Input.}
  \label{fig:input}
\end{figure}

\begin{figure}[ht]
  \centering
  \includesvg[width=0.8\columnwidth]{output}
  \caption{Wire format of an Output.}
  \label{fig:output}
\end{figure}

An output does not send money to a given address, but defines how the money can
  be spent. Currently there are two formats in use. The most used is called
  ``Pay To Public Key Hash'' (P2PKH)\footnote{The key hash is the address of an
  account}. The other is called ``Pay To Script Hash'' (P2SH).

As figure~\ref{fig:output} shows, the output has a script on its wire
  representation.
This script is written in a small stack based language.
It is read from left to right and it is purposefully not Turing-complete.
The script is evaluated using the scriptSig as input. If the transaction willing
  to spend this output provides a valid\footnote{A script is considered valid
  if after its execution the value in the top of the stack is True.} scriptSig,
  the output is available to be spend. This is how a P2PKH script looks like:

\begin{center}
  \begin{tabular}{|c|}
    \texttt{OP\_DUP OP\_HASH160 <pubKeyHash> OP\_EQUALVERIFY OP\_CHECKSIG}
  \end{tabular}
\end{center}

  It receives two values as input:  \lstinline{<pubKeyHash>} and
  \lstinline{<sig>}. And the execution is explained in
  table~\ref{tab:p2pkh_exec}.

\begin{table}[tbp]
  \small
    \begin{tabularx}{\textwidth}{| c | X |}
    \hline
	    \thead{Stack} & \thead{Script} \\
	\hline
      \multicolumn{2}{|l|}{\textbf{Step 1: }\textit{%
          Constants from scriptSig are copied to the stack.}} \\
    \hline
	  \makecell{<pubKey>\\<sig>} & OP\_DUP \footnotesize{%
          OP\_HASH160 <pubKeyHash> OP\_EQUALVERIFY OP\_CHECKSIG} \\
    \hline
	  \multicolumn{2}{|l|}{\textbf{Step 2: }\textit{%
	      OP\_DUP copies the top element from the stack.}} \\
    \hline
      \makecell{<pubKey> \\ <pubKey> \\ <sig>} & OP\_HASH160 \footnotesize{%
          <pubKeyHash> OP\_EQUALVERIFY OP\_CHECKSIG} \\
	\hline
      \multicolumn{2}{|l|}{\textbf{Step 3: }\textit{%
          The hash of the top element is calculated.}} \\
    \hline
	  \makecell{H(<pubKey>) \\ <pubKey> \\ <sig>} & <pubKeyHash> \footnotesize{%
          OP\_EQUALVERIFY OP\_CHECKSIG} \\
    \hline
	  \multicolumn{2}{|l|}{\textbf{Step 4: }\textit{%
	      The destination address is moved to the stack.}} \\
	\hline
	  \makecell{<pubKeyHash> \\ H(<pubKey>) \\ <pubKey> \\ <sig>} &%
	      OP\_EQUALVERIFY \footnotesize{OP\_CHECKSIG} \\
	\hline
	  \multicolumn{2}{|l|}{\textbf{Step 5: }\textit{%
	      The destination address is compared with the Hash of the %
          Public Key (PK) provided by}} \\
	  \multicolumn{2}{|l|}{\textit{the sig Script. This checks that the provided %
	      Public Key is the one from the intended receiver.}} \\
	\hline
	  \makecell{<pubKey> \\ <sig>} & OP\_CHECKSIG \\
	\hline
	  \multicolumn{2}{|l|}{\textbf{Step 6: }\textit{%
	      Using the already verified PK, the script checks that the transaction was %
          signed using the}} \\
	  \multicolumn{2}{|l|}{\textit{corresponding Private Key. This step %
	      secures the transaction from tampering an proves it was}} \\
	  \multicolumn{2}{|l|}{\textit{sent by the private Key controller.}} \\
	\hline
	  \makecell{True} & \\
	\hline
    \end{tabularx}
    \caption{Script evaluation to check a P2PKH transaction.}
    \label{tab:p2pkh_exec}
  % small
\end{table}

The scriptPubKey in a pay to script hash transaction is even simpler:
\begin{center}
	\begin{tabular}{|c|}
		\texttt{OP\_HASH160 <scriptHash> OP\_EQUAL}
	\end{tabular}
\end{center}
This script is pretty simple, it takes the first element of the stack,
  calculates its hash and compares it with '<scriptHash>'. The first
  element in the stack is however a complete script, and after checking
  it hashes to the expected scriptHash. It will be evaluated with its
  required input. This implies the scriptSig now holds the script and
  its signature:

\begin{center}
	\begin{tabular}{|c|}
		\texttt{<sig> >script>}
	\end{tabular}
	% \caption*{P2SH sigScript.}
\end{center}


  A execution of a sample P2SH is shown in table~\ref{tab:p2sh_exec}.

\begin{table}[tbp]
  \small
	\begin{tabularx}{\textwidth}{| c | X |}
	  \hline
	    \thead{Stack} & \thead{Script} \\
	  \hline
	  \multicolumn{2}{|c|}{\textbf{Step 1: }\textit{%
	      The serialized script and its input are copied to the stack.}} \\
	  \hline
		\makecell{\{<pubkey> OP\_CHECKSIG\} \\ <sig> } & %
	      OP\_HASH160 \footnotesize{<scriptHash> OP\_EQUAL} \\
	  \hline
		\multicolumn{2}{|l|}{\textbf{Step 2: }\textit{%
		  The serialized script hash is calculated.}} \\
      \hline
		\makecell{H(\{<pubkey> OP\_CHECKSIG\}) \\ <sig>} & %
	      <pubkeyHash> \footnotesize{OP\_EQUAL} \\
	  \hline
		\multicolumn{2}{|l|}{\textbf{Step 3: }\textit{%
		  The expected hash is pushed to the stack.}} \\
	  \hline
		\makecell{<pubKeyHash> \\ %
		    H(\{<pubkey> OP\_CHECKSIG\}) \\ <sig>} & OP\_EQUAL \\
	  \hline
		\multicolumn{2}{|l|}{\textbf{Step 4: }\textit{%
		    Hashes are compared, and if they match, the script is deserialized and evaluated.}} \\
      \hline
	    \makecell{<sig>} & <pubkey> \footnotesize{OP\_CHECKSIG} \\
	  \hline
	    \multicolumn{2}{|l|}{\textbf{Step 5: }\textit{%
	      The public key is pushed to the stack.}} \\
	  \hline
		\makecell{<pubKey> \\ <sig>} & OP\_CHECKSIG \\
	  \hline
		\multicolumn{2}{|l|}{\textbf{Step 6: }\textit{%
		    The provided signature is validated using the public key.}} \\
	  \hline
	    \makecell{True} & \\
	  \hline
	\end{tabularx}
    \caption{Script evaluation of a P2SH transaction.}
	\label{tab:p2sh_exec}
  % \end small
\end{table}

A P2SH transaction allows different conditions to redeem its outputs.
A complete list of the operations supported by the Bitcoin scripting language
  can be found at the Bitcoin wiki: \url{https://en.bitcoin.it/wiki/Script}.
